<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRISONER COMIC // v3.4</title>
    
    <script src="https://unpkg.com/blockly/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly/msg/en.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Patrick+Hand&display=swap');

        :root {
            --bg-color: #ffffff;
            --border-color: #000000;
            --primary-accent: #ff0000;
            --secondary-accent: #0099ff;
            --success-color: #00cc00;
            --border-width: 3px;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Comic Neue', cursive;
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: #000;
            min-height: 100vh;
        }

        .container { max-width: 1600px; margin: 0 auto; padding: 2rem; }

        /* --- Header --- */
        header {
            text-align: center; margin-bottom: 3rem;
            display: flex; flex-direction: column; align-items: center;
        }
        .hero-image {
            width: 600px; height: 200px;
            border: var(--border-width) solid var(--border-color);
            box-shadow: 5px 5px 0px #000;
            margin-bottom: 1.5rem;
            background: #f0f0f0;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Patrick Hand'; font-size: 2rem; color: #aaa;
        }
        h1 {
            font-family: 'Patrick Hand', cursive; font-size: 4rem; margin: 0;
            text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 2px 2px 0px #ccc;
        }

        /* --- Panels --- */
        .main-grid { display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 2rem; }
        
        .panel {
            background: #fff;
            border: var(--border-width) solid var(--border-color);
            padding: 2rem;
            box-shadow: 5px 5px 0px #000;
        }

        h2 {
            font-family: 'Patrick Hand', cursive; font-size: 2.2rem;
            margin-top: 0; border-bottom: var(--border-width) solid #000;
            padding-bottom: 0.5rem; display: flex; align-items: center;
        }

        /* --- Buttons & Inputs --- */
        .controls-bar { display: flex; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap; }
        
        button, .btn-label {
            background: #fff; border: var(--border-width) solid #000;
            padding: 0.8rem 1.5rem; font-family: 'Patrick Hand', cursive;
            font-size: 1.2rem; font-weight: bold; text-transform: uppercase;
            cursor: pointer; box-shadow: 3px 3px 0px #000;
        }
        button:hover, .btn-label:hover { transform: translate(-2px, -2px); box-shadow: 5px 5px 0px #000; background: #f4f4f4; }
        button:active { transform: translate(2px, 2px); box-shadow: 1px 1px 0px #000; }
        
        button.btn-success { background: #eaffea; }
        button.btn-accent { background: #ffeaea; }

        /* --- Workspace --- */
        #blockly-container {
            height: 600px; width: 100%;
            border: var(--border-width) solid #000;
        }

        /* --- Results & Logs --- */
        .score-board { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem; }
        .score-card {
            border: var(--border-width) solid #000; padding: 1rem; text-align: center;
            box-shadow: 3px 3px 0px #000;
        }
        .score-value { font-size: 3.5rem; font-family: 'Patrick Hand'; font-weight: 700; }
        .score-p1 { color: var(--secondary-accent); }
        .score-p2 { color: var(--primary-accent); }

        .log-container {
            height: 300px; overflow-y: auto;
            border: var(--border-width) solid #000; padding: 1rem;
            font-weight: bold;
        }
        .log-entry { display: flex; justify-content: space-between; padding: 0.4rem 0; border-bottom: 1px dashed #ccc; }
        .move-cooperate { color: var(--success-color); }
        .move-defect { color: var(--primary-accent); }

        /* --- Tournament --- */
        .tournament-section { margin-top: 2rem; grid-column: 1 / -1; }
        .strategy-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem; }
        .strategy-item {
            border: 2px solid #eee; padding: 0.5rem; display: flex; align-items: center; gap: 0.5rem;
        }
        .strategy-item input { width: 20px; height: 20px; accent-color: #000; }
        
        .results-table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        .results-table th { text-align: left; padding: 1rem; border-bottom: 3px solid #000; font-family: 'Patrick Hand'; }
        .results-table td { padding: 1rem; border-bottom: 1px solid #eee; font-weight: bold; }
        .rank-1 { color: #eebb00; font-size: 1.2em; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <div class="hero-image">COMIC IMAGE HERE</div>
        <h1>PRISONER'S DILEMMA</h1>
        <div style="font-family:'Patrick Hand'; font-size:1.5rem; color:#666;">A Game of Trust (and Betrayal)</div>
    </header>

    <div class="main-grid">
        <div class="panel">
            <h2>STRATEGY DECK <button id="new-algorithm" style="margin-left:auto; font-size:1rem;">RESET</button></h2>
            
            <xml id="toolbox" style="display: none">
                <category name="Decisions" colour="160">
                    <block type="prisoner_decision"></block>
                    <block type="return_decision"></block>
                </category>
                <category name="Game State" colour="230">
                    <block type="opponent_last_move"></block>
                    <block type="round_number"></block>
                </category>
                <category name="Logic" colour="210">
                    <block type="controls_if"></block>
                    <block type="logic_compare"></block>
                    <block type="logic_operation"></block>
                    <block type="logic_boolean"></block>
                </category>
                <category name="Math" colour="280">
                    <block type="math_number"></block>
                    <block type="math_arithmetic"></block>
                    <block type="math_random_float"></block>
                </category>
                <category name="Variables" custom="VARIABLE" colour="330"></category>
            </xml>

            <div id="blockly-container"></div>

            <div class="controls-bar">
                <button id="test-algorithm" class="btn-success">TEST IT!</button>
                <button id="save-strategy">SAVE XML</button>
                <label class="btn-label">LOAD XML <input type="file" id="upload-strategy" accept=".xml" style="display:none"></label>
                <button id="clear-workspace" class="btn-accent">CLEAR</button>
            </div>
        </div>

        <div class="panel">
            <h2>SIMULATION</h2>
            <div class="score-board">
                <div class="score-card"><h3 class="score-p1">YOU</h3><div id="your-score" class="score-value">0</div></div>
                <div class="score-card"><h3 class="score-p2">THEM</h3><div id="opponent-score" class="score-value">0</div></div>
            </div>
            
            <div style="margin-bottom:1rem; display:flex; gap:1rem;">
                <div style="flex:1">
                    <label>OPPONENT</label>
                    <select id="opponent-strategy" style="width:100%; padding:0.5rem; border:3px solid #000; font-family:'Comic Neue'; font-weight:bold;"></select>
                </div>
                <div style="width:80px">
                    <label>ROUNDS</label>
                    <input type="number" id="rounds" value="100" style="width:100%; padding:0.5rem; border:3px solid #000;">
                </div>
            </div>

            <div id="game-log-content" class="log-container"></div>
        </div>

        <div class="panel tournament-section">
            <h2>TOURNAMENT MODE</h2>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:2rem">
                <div>
                    <h3 style="font-family:'Patrick Hand'">PRESETS</h3>
                    <div id="preset-strategies-list" class="strategy-list"></div>
                </div>
                <div>
                    <h3 style="font-family:'Patrick Hand'">CUSTOM UPLOADS</h3>
                    <label class="btn-label" style="display:block; text-align:center; margin-top:1rem;">
                        + UPLOAD FILES
                        <input type="file" id="upload-tournament-strategies" accept=".xml" multiple style="display:none">
                    </label>
                    <div id="uploaded-files-list" class="strategy-list"></div>
                </div>
            </div>
            <button id="run-tournament" class="btn-accent" style="width:100%; margin-top:2rem; font-size:1.5rem;">RUN TOURNAMENT</button>
            
            <div id="tournament-results-container" style="display:none; margin-top:2rem;">
                <h3 style="text-align:center; font-family:'Patrick Hand'; font-size:2rem;">LEADERBOARD</h3>
                <table class="results-table">
                    <thead><tr><th>RANK</th><th>STRATEGY</th><th style="text-align:right">SCORE</th></tr></thead>
                    <tbody id="tournament-results-body"></tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 1. Block Definitions ---
    Blockly.Blocks['prisoner_decision'] = {
        init: function() {
            this.appendDummyInput().appendField("Decision").appendField(new Blockly.FieldDropdown([["COOPERATE","COOPERATE"], ["DEFECT","DEFECT"]]), "DECISION");
            this.setOutput(true, "Decision");
            this.setColour(160);
        }
    };
    Blockly.Blocks['opponent_last_move'] = {
        init: function() {
            this.appendDummyInput().appendField("Opponent's Last Move");
            this.setOutput(true, "Decision");
            this.setColour(230);
        }
    };
    Blockly.Blocks['round_number'] = {
        init: function() {
            this.appendDummyInput().appendField("Round Number");
            this.setOutput(true, "Number");
            this.setColour(280);
        }
    };
    Blockly.Blocks['return_decision'] = {
        init: function() {
            this.appendValueInput("DECISION").setCheck("Decision").appendField("Play Card:");
            this.setPreviousStatement(true, null);
            this.setColour(160);
        }
    };

    // --- 2. Generators ---
    Blockly.JavaScript['prisoner_decision'] = function(block) { return ["'" + block.getFieldValue('DECISION') + "'", Blockly.JavaScript.ORDER_ATOMIC]; };
    Blockly.JavaScript['opponent_last_move'] = function(block) { return ['opponentLastMove', Blockly.JavaScript.ORDER_ATOMIC]; };
    Blockly.JavaScript['round_number'] = function(block) { return ['roundNumber', Blockly.JavaScript.ORDER_ATOMIC]; };
    Blockly.JavaScript['return_decision'] = function(block) { 
        var code = Blockly.JavaScript.valueToCode(block, 'DECISION', Blockly.JavaScript.ORDER_NONE) || "'COOPERATE'";
        return "return " + code + ";\n";
    };

    // --- 3. Game Logic ---
    class GameEngine {
        constructor() {
            this.strats = {
                'random': () => Math.random() > 0.5 ? 'COOPERATE' : 'DEFECT',
                'always_defect': () => 'DEFECT',
                'always_cooperate': () => 'COOPERATE',
                'tit_for_tat': (ctx) => ctx.opponentLastMove || 'COOPERATE'
            };
        }
        run(algorithm, vs, rounds) {
            const history = [];
            let p1s = 0, p2s = 0;
            const persistentContext = { variables: {} };
            
            for(let r=1; r<=rounds; r++){
                const p1Ctx = { roundNumber: r, opponentLastMove: history.length > 0 ? history[history.length-1].p2 : null, variables: persistentContext.variables };
                const p2Ctx = { roundNumber: r, opponentLastMove: history.length > 0 ? history[history.length-1].p1 : null, opponentHistory: history.map(h=>h.p1) };
                
                let p1m, p2m;
                try { p1m = algorithm(p1Ctx); } catch(e) { console.error(e); p1m = 'COOPERATE'; }
                try { p2m = this.strats[vs](p2Ctx); } catch(e) { p2m = 'COOPERATE'; }

                if(p1m !== 'COOPERATE' && p1m !== 'DEFECT') p1m = 'COOPERATE';
                if(p2m !== 'COOPERATE' && p2m !== 'DEFECT') p2m = 'COOPERATE';

                const sc = this.scores(p1m, p2m);
                p1s += sc.p1; p2s += sc.p2;
                history.push({r, p1:p1m, p2:p2m, p1Score:sc.p1, p2Score:sc.p2});
            }
            return {history, p1s, p2s};
        }
        scores(m1, m2) {
            if(m1==='COOPERATE' && m2==='COOPERATE') return {p1:3, p2:3};
            if(m1==='DEFECT' && m2==='COOPERATE') return {p1:5, p2:0};
            if(m1==='COOPERATE' && m2==='DEFECT') return {p1:0, p2:5};
            return {p1:1, p2:1};
        }
    }

    // --- 4. Initialization ---
    let workspace = null;
    const gameEngine = new GameEngine();
    let uploadedStrategies = [];

    window.addEventListener('load', function() {
        // Initialize UI FIRST (So it works even if Blockly fails)
        setupUI();
        setupEvents();

        // Then Inject Blockly
        workspace = Blockly.inject('blockly-container', {
            toolbox: document.getElementById('toolbox'),
            trashcan: true,
            theme: Blockly.Themes.Classic
        });
        
        // Then Load Blocks
        setTimeout(loadDefaultAlgorithm, 100); 
    });

    function setupUI() {
        // Opponent Dropdown
        const sel = document.getElementById('opponent-strategy');
        sel.innerHTML = '';
        Object.keys(gameEngine.strats).forEach(k => {
            const opt = document.createElement('option');
            opt.value = k; opt.textContent = k.toUpperCase().replace(/_/g,' ');
            sel.appendChild(opt);
        });
        // Default to Random
        sel.value = 'random';

        // Tournament Presets
        const list = document.getElementById('preset-strategies-list');
        list.innerHTML = Object.keys(gameEngine.strats).map(k => 
            `<div class="strategy-item"><input type="checkbox" id="pre-${k}" value="${k}" checked> <label for="pre-${k}" style="cursor:pointer; flex-grow:1;">${k.toUpperCase().replace(/_/g,' ')}</label></div>`
        ).join('');
    }

    function setupEvents() {
        document.getElementById('test-algorithm').addEventListener('click', runTest);
        document.getElementById('new-algorithm').addEventListener('click', loadDefaultAlgorithm);
        document.getElementById('clear-workspace').addEventListener('click', () => confirm('Clear?') && workspace.clear());
        document.getElementById('save-strategy').addEventListener('click', downloadXML);
        document.getElementById('upload-strategy').addEventListener('change', uploadXML);
        document.getElementById('upload-tournament-strategies').addEventListener('change', handleTournamentUpload);
        document.getElementById('run-tournament').addEventListener('click', runTournament);
    }

    function loadDefaultAlgorithm() {
        if(!workspace) return;
        workspace.clear();
        // Define default: Always Cooperate
        const xmlText = `<xml xmlns="https://developers.google.com/blockly/xml"><block type="return_decision" x="50" y="50"><value name="DECISION"><block type="prisoner_decision"><field name="DECISION">COOPERATE</field></block></value></block></xml>`;
        try {
            Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(xmlText), workspace);
        } catch(e) {
            console.error("XML Load Error: ", e);
        }
    }

    function runTest() {
        const code = Blockly.JavaScript.workspaceToCode(workspace);
        if(!code) return alert("Empty workspace!");
        
        const funcBody = `const {roundNumber, opponentLastMove, variables} = context; ${code} return 'COOPERATE';`;
        const algorithm = new Function('context', funcBody);
        
        const opponent = document.getElementById('opponent-strategy').value || 'random';
        const rounds = parseInt(document.getElementById('rounds').value) || 100;
        
        const res = gameEngine.run(algorithm, opponent, rounds);
        
        document.getElementById('your-score').textContent = res.p1s;
        document.getElementById('opponent-score').textContent = res.p2s;
        
        const log = document.getElementById('game-log-content');
        log.innerHTML = res.history.map(h => {
            const c1 = h.p1==='COOPERATE'?'move-cooperate':'move-defect';
            const c2 = h.p2==='COOPERATE'?'move-cooperate':'move-defect';
            return `<div class="log-entry"><span>R${h.r}</span><span class="${c1}">YOU: ${h.p1[0]}</span><span class="${c2}">THEM: ${h.p2[0]}</span><span>${h.p1Score}-${h.p2Score}</span></div>`;
        }).join('');
        log.scrollTop = log.scrollHeight;
    }

    // --- 5. Tournament Logic ---
    function handleTournamentUpload(e) {
        Array.from(e.target.files).forEach(file => {
            const r = new FileReader();
            r.onload = (ev) => {
                const name = file.name.replace(/\.xml$/,'');
                uploadedStrategies.push({name, xml: ev.target.result});
                const div = document.createElement('div');
                div.className = "strategy-item";
                div.innerHTML = `<input type="checkbox" id="custom-${name}" value="${name}" checked> <label for="custom-${name}" style="cursor:pointer; flex-grow:1;">${name}</label>`;
                document.getElementById('uploaded-files-list').appendChild(div);
            };
            r.readAsText(file);
        });
    }

    function runTournament() {
        const btn = document.getElementById('run-tournament');
        btn.disabled = true; btn.textContent = "RUNNING...";
        document.getElementById('tournament-results-container').style.display = 'none';

        const players = [];
        
        // Gather Checked Presets
        const presetChecks = document.querySelectorAll('#preset-strategies-list input[type="checkbox"]:checked');
        presetChecks.forEach(i => {
            players.push({name: i.value, fn: gameEngine.strats[i.value], score:0});
        });

        // Gather Checked Uploads
        const uploadChecks = document.querySelectorAll('#uploaded-files-list input[type="checkbox"]:checked');
        uploadChecks.forEach(i => {
            const data = uploadedStrategies.find(u => u.name === i.value);
            if(data) {
                const ws = new Blockly.Workspace();
                Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(data.xml), ws);
                const code = Blockly.JavaScript.workspaceToCode(ws);
                ws.dispose();
                const fn = new Function('context', `const {roundNumber, opponentLastMove, variables} = context; ${code} return 'COOPERATE';`);
                players.push({name: data.name, fn, score:0});
            }
        });

        if(players.length < 2) { 
            alert("Please select at least 2 strategies!"); 
            btn.disabled=false; 
            btn.textContent="RUN TOURNAMENT"; 
            return; 
        }

        // Round Robin Simulation
        for(let i=0; i<players.length; i++) {
            for(let j=i; j<players.length; j++) {
                const rounds = 100;
                let h1=[], h2=[], p1s=0, p2s=0;
                
                for(let r=1; r<=rounds; r++) {
                    const ctx1 = {roundNumber:r, opponentLastMove: h2.length?h2[h2.length-1]:null, opponentHistory:h2};
                    const ctx2 = {roundNumber:r, opponentLastMove: h1.length?h1[h1.length-1]:null, opponentHistory:h1};
                    let m1='COOPERATE', m2='COOPERATE';
                    try { m1 = players[i].fn(ctx1); } catch(e){}
                    try { m2 = players[j].fn(ctx2); } catch(e){}
                    if(m1!=='DEFECT') m1='COOPERATE';
                    if(m2!=='DEFECT') m2='COOPERATE';
                    
                    const s = gameEngine.scores(m1,m2);
                    p1s+=s.p1; p2s+=s.p2;
                    h1.push(m1); h2.push(m2);
                }
                
                if(i===j) { 
                    players[i].score += p1s; // Self-play adds to own score
                } else { 
                    players[i].score += p1s; 
                    players[j].score += p2s; 
                }
            }
        }

        // Render Leaderboard
        const body = document.getElementById('tournament-results-body');
        body.innerHTML = '';
        players.sort((a,b) => b.score - a.score).forEach((p, idx) => {
            const tr = document.createElement('tr');
            const cls = idx===0?'rank-1':'';
            tr.innerHTML = `<td class="${cls}">#${idx+1}</td><td style="font-weight:bold">${p.name.toUpperCase().replace(/_/g,' ')}</td><td style="text-align:right">${p.score}</td>`;
            body.appendChild(tr);
        });
        
        document.getElementById('tournament-results-container').style.display = 'block';
        btn.disabled = false; btn.textContent = "RUN TOURNAMENT";
    }

    // XML Helpers
    function downloadXML() {
        const xml = Blockly.Xml.workspaceToDom(workspace);
        const blob = new Blob([Blockly.Xml.domToText(xml)], {type:'text/xml'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download = 'strategy.xml';
        a.click();
    }
    function uploadXML(e) {
        const f = e.target.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = (ev) => {
            workspace.clear();
            Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(ev.target.result), workspace);
        };
        r.readAsText(f);
    }
</script>
</body>
</html>
